/*
 * @Author: Weijie Li 
 * @Date: 2017-11-06 22:04:17 
 * @Last Modified by: Weijie Li
 * @Last Modified time: 2017-12-27 10:39:04
 */


#ifndef  _SM4_WHITEBOX_H_
#define  _SM4_WHITEBOX_H_

#include <stdint.h>

#include <openssl/sm4.h>
#include <openssl/wbmatrix.h>
#include <openssl/modes.h>
#include <string.h>

#define WBSM4_ENABLE 1

#define SM4_WHITEBOX_F 1
#define SM4_WHITEBOX_DEBUG_INFO_F 0
#define SM4_WHITEBOX_UNROLL_F 0

#define WBSM4_DUMMY_ROUND_ENABLE 1

#define SM4_WHITEBOX_DUMMYROUND_F 1
#define SM4_WHITEBOX_DUMMY_ROUND_MAX 30
#define SM4_WHITEBOX_ROUND_MAX (SM4_WHITEBOX_DUMMY_ROUND_MAX+SM4_NUM_ROUNDS)

#define SM4_WHITEBOX_NUM_STATES (SM4_WHITEBOX_ROUND_MAX+4)

#ifdef __cplusplus
extern "C" {
#endif

#if SM4_WHITEBOX_F



#define SM4_ENCRYPT 1
#define SM4_DECRYPT 0


typedef struct sm4_key_t {
	uint32_t rk[SM4_NUM_ROUNDS];
#ifdef SM4_EXTERNAL_ENCODINGS
    uint8_t G[SM4_NUM_ROUNDS+1][256];
    uint8_t F[SM4_NUM_ROUNDS+1][256];
#endif //SM4_EXTERNAL_ENCODINGS
} sm4_key_t;

typedef struct sm4_wb_t{
    uint32_t rounds;

    uint32_t    ssbox_enc[SM4_WHITEBOX_ROUND_MAX][4][256];
    Aff32 M[SM4_WHITEBOX_ROUND_MAX][3];
    Aff32 C[SM4_WHITEBOX_ROUND_MAX];
    Aff32 D[SM4_WHITEBOX_ROUND_MAX];
    
    // start encoding
    Aff32 SE[4];
    Aff32 FE[4];
     

} Sm4Whitebox;


/**
 sm4_set_encrypt_key

 @param key SM4_KEY
 @param user_key key
 */
void sm4_set_encrypt_key(sm4_key_t *key, const unsigned char *user_key);

/**
 sm4_set_decrypt_key

 @param key SM4_KEY
 @param user_key key
 */
void sm4_set_decrypt_key(sm4_key_t *key, const unsigned char *user_key);

/**
 * @brief sm4 whitebox encrypto function  
 * 
 * @param in both plaintext and ciphertext are ok, only accept one block: 16 uint8_t 
 * @param out the text that processed by sm4_wb_ctx 
 * @param sm4_wb_ctx sm4_whitebox ctx, generated by int sm4_wb_gen_tables(const uint8_t *key, Sm4Whitebox *sm4_wb_ctx, int enc) or int sm4_wb_gen_tables_with_dummyrounds(const uint8_t *key, Sm4Whitebox *sm4_wb_ctx, int enc, int dummyrounds);
 */
void sm4_wb_enc(const uint8_t *in, uint8_t *out, Sm4Whitebox *sm4_wb_ctx);

#define sm4_wb_encrypt(in,out,sm4_wb_ctx) sm4_wb_enc(in, out, sm4_wb_ctx);
#define sm4_wb_decrypt(in,out,sm4_wb_ctx)  sm4_wb_encrypt(in,out,sm4_wb_ctx)


/**
 * @brief free the space of sm4_wb_ctx
 * 
 * @param sm4_wb_ctx 
 * @return int 0 is successful, otherwise fault
 */


#define sm4_wb_free(sm4p) \
    free(sm4p);\
    sm4p = NULL;


/**
 sm4_wb_cbc_encrypt

 @param in in
 @param out out
 @param len byte size of in
 @param ctx key sm4_whitebox_ctx
 @param iv iv
 */
void sm4_wb_cbc_encrypt(const unsigned char *in, unsigned char *out,
	size_t len, const Sm4Whitebox * ctx, unsigned char *iv);

/**
 sm4_wb_cbc_decrypt

 @param in in
 @param out out
 @param len byte size of in
 @param ctx key sm4_whitebox_ctx
 @param iv iv
 */
void sm4_wb_cbc_decrypt(const unsigned char *in, unsigned char *out,
	size_t len, const Sm4Whitebox * ctx, unsigned char *iv);


/**
 * @brief export Sm4Whitebox to byte
 * 
 * @param ctx a pointer of Sm4Whitebox
 * @param dest a pointer to a pointer of byte[]
 * @return int byte[] size
 */
int sm4_wb_export_to_str(const Sm4Whitebox* ctx, void **dest) ;

/**
 * @brief import Sm4Whitebox from str
 * 
 * @param source 
 * @return Sm4Whitebox* 
 */
Sm4Whitebox*  sm4_wb_import_from_str(const void *source);



GCM128_CONTEXT *sm4_wb_gcm128_init_new(Sm4Whitebox *wb_ctx);
/**
 sm4_wb_gcm128_init

 @param gcm_ctx SM4_WB_GCM128_CONTEXT
 @param wb_ctx Sm4Whitebox
 */
void sm4_wb_gcm128_init(GCM128_CONTEXT *gcm_ctx, Sm4Whitebox *wb_ctx);

/**
 sm4_wb_gcm128_setiv

 @param gcm_ctx SM4_WB_GCM128_CONTEXT
 @param ivec iv
 @param len byte size of iv
 */
void sm4_wb_gcm128_setiv(GCM128_CONTEXT *gcm_ctx, const unsigned char *ivec,
                      size_t len);

/**
 addition message of gcm

 @param gcm_ctx SM4_WB_GCM128_CONTEXT
 @param aad addition message
 @param len byte size of aad
 @return 1 to successful, otherwises fault
 */
int sm4_wb_gcm128_aad(GCM128_CONTEXT *gcm_ctx, const unsigned char *aad,
                    size_t len);

/**
 sm4_wb_gcm128_encrypt

 @param in in
 @param out out
 @param length byte size of in
 @param gcm_ctx SM4_WB_GCM128_CONTEXT
 @param enc 1 to SM4_ENCRYPT, 0 to SM4_DECRYPT
 @return 1 to successful, otherwises fault
 */
int sm4_wb_gcm128_encrypt(const unsigned char *in, unsigned char *out,
                        size_t length, GCM128_CONTEXT *gcm_ctx, const int enc);

/**
 get tag of sm4_wb_gcm128

 @param gcm_ctx SM4_WB_GCM128_CONTEXT
 @param tag memory for storage tag
 @param len byte size of tag
 */
void sm4_wb_gcm128_tag(GCM128_CONTEXT *gcm_ctx, unsigned char *tag,
                    size_t len);

/**
 sm4_wb_gcm128_finish

 @param gcm_ctx SM4_WB_GCM128_CONTEXT
 @param tag memory for storage tag
 @param len byte size of tag
 @return 1 to successful, otherwises fault
 */
int sm4_wb_gcm128_finish(GCM128_CONTEXT *gcm_ctx, const unsigned char *tag,
                      size_t len);

/**
 release SM4_WB_GCM128_CONTEXT

 @param gcm_ctx SM4_WB_GCM128_CONTEXT
 */
void sm4_wb_gcm128_release(GCM128_CONTEXT *gcm_ctx);

#endif /* SM4_WHITEBOX_F */



#ifdef __cplusplus
}
#endif
#endif //_SM4_WHITEBOX_H_